program = _{SOI~statement* ~ EOI}

statement = _{
    emptyStatement
  | importStatement ~ eos?
  | traitStatement ~ eos?
  | controlFlow ~ eos?
  | assignStatement ~ eos?
  | annotation ~ eos?
  | expr ~ eos?
}
/*====================================================================================================================*/
emptyStatement = {eos | Separate }
eos = {Semicolon}
comma_or_semi = _{Comma|Semicolon}
block_or_expr = _{block|Set ~ expr}
/*====================================================================================================================*/
//FIXME: 修复 nested using
importStatement = {
    Import ~ Dot* ~ use_alias
  | Import ~ Dot* ~ use_module_select
  | Import ~ use_module_string
}
use_alias = !{String ~ As ~ SYMBOL|SYMBOL ~ (ModuleSplit ~ SYMBOL)* ~As~SYMBOL}
use_module_select = !{SYMBOL ~ (ModuleSplit ~ SYMBOL)* ~(ModuleSplit ~ (module_block|Star))?}
use_module_string = !{String ~ (ModuleSplit ~ (module_block|Star))?}
module_block = {"{"~module_tuple~ ( comma_or_semi? ~ module_tuple)* ~comma_or_semi?~"}"}
module_tuple = {use_alias|use_module_select}
ModuleSplit= _{Dot|Proportion}
//!#C678DD: With|Import|As
With = @{"with"}
Import  = @{"import"}
As   = @{"as"}
/*====================================================================================================================*/
controlFlow = _{if_statement|for_statement}
block = !{"{" ~ statement+ ~ "}"}
/*====================================================================================================================*/
if_statement ={if_nested_else|if_nested|if_single_else|if_single}
if_single = _{ If~condition~ block}
if_nested = _{ If~ condition~ block ~ else_if_block+}
if_single_else = _{ If~condition~ block ~ if_else_block}
if_nested_else = _{ If~ condition~ block~ else_if_block+ ~ if_else_block}
else_if_block = !{ Else ~ If ~condition~ block}
if_else_block = _{ Else ~ block}
//!#C678DD: If|Else
If = @{"if"}
Else = @{"else"}
/*====================================================================================================================*/
for_statement = _{For ~ for_in_loop}
for_in_loop = {SYMBOL~In~expr~block}
//!#C678DD: For|In
For = @{"for"}
In = @{"in"}
/*====================================================================================================================*/
//!#C678DD: Return|Break|Pass
Return = @{"return"}
Break = @{"break"}
Pass = @{"pass"}
/*====================================================================================================================*/
traitStatement = { trait_head ~"{" ~ traitExpression*  ~ "}"   }
trait_head = _{Trait ~ SYMBOL ~classExtend?}
traitExpression= { interfaceFunction ~Colon ~type_expr~comma_or_semi?}
interfaceFunction= { SYMBOL ~"(" ~interfaceParameters? ~")"~ Question?}
interfaceParameters= {type_expr ~SYMBOL ~ (Comma ~type_expr~ SYMBOL )*}
classExtend =${"extend"}
Trait = @{"trait"}
/*====================================================================================================================*/
assignStatement = _{set_assign|let_assign}
let_assign = {
    Let ~ "(" ~ assign_name ~ ")" ~type_hint? ~ block_or_expr?
  | Let ~ assign_name ~ type_hint? ~ block_or_expr?
}
set_assign = {
    "(" ~ SYMBOL  ~ (Comma ~ SYMBOL)* ~ Comma?  ~ ")" ~ Set ~ statement
  | SYMBOL ~ Set ~ statement
}
assign_name = {assign_pair ~ (Comma ~ assign_pair)* ~ Comma?}
assign_pair = {(!(SYMBOL~(Comma|Set|Colon|Semicolon|"{")) ~modifier)* ~ SYMBOL}

///Orange
modifier = ${Symbol}
//!#C678DD: Let
Let = @{"let"}
/*====================================================================================================================*/
//!Orange:annotation_call
annotation = {annotation_call+~statement}
annotation_call = @{At~(list|apply|Symbol)}
/*====================================================================================================================*/
apply = {
     "(" ~ expr? ~")"
}
methodApply = {expr ~Dot ~ function_name ~ "(" ~ expr? ~")"}


///#61AFEF
function_name = {SYMBOL}
function_module = {(namespace ~ Dot)? ~ (SYMBOL ~ Dot)*}
/*====================================================================================================================*/
expr = !{
    trinocular
  | bracket_call
  | term ~ (Infix ~ term)*
}
term =  {Prefix* ~ node ~ Postfix*}
node = {data| "(" ~ expr ~ ")"}
condition  = {node|expr}
expressions = {"("~expr~ (comma_or_semi? ~ expr)* ~comma_or_semi?~")"}
bracket_call = {term ~ (slice|apply)+}
trinocular = {
    term ~ Question ~ expr ~ Colon ~ expr
  | term ~ If ~ expr ~ Else ~ expr
}
/*====================================================================================================================*/
/// #E06C75
type_expr = !{ SYMBOL | apply|type_term ~ (Infix ~ type_term)*}
type_term =  { Prefix* ~ type_node ~ Postfix* }
type_node = _{ "(" ~ type_expr ~ ")" }
type_hint = { Colon ~ type_expr}

//!#C678DD: Type|To
Type = @{"type"}
/*====================================================================================================================*/
data = {dict|list|Null|Boolean|Byte|Number|String|Symbol}
dict = {"{" ~key_value? ~(Comma ~key_value)* ~Comma? ~"}"}
list = {"[" ~expr? ~(Comma ~expr)* ~Comma? ~"]"}
slice ={"[" ~index ~(Comma ~index)* ~Comma? ~"]"}
index ={index_step|index_range|expr}
key_value =!{key_valid ~ Colon ~expr}
key_valid =!{Integer | SYMBOL | String}
index_range = !{expr? ~ Colon ~ expr?}
index_step = !{expr? ~ Colon ~ expr? ~ Colon ~ expr?}
/*====================================================================================================================*/
///#C678DD
Null = @{"null"}
/*====================================================================================================================*/
///#C678DD
Boolean = !{True|False}
True    = @{"true"}
False   = @{"false"}
/*====================================================================================================================*/
///#D19A66
Byte     = ${Byte_BIN|Byte_OCT|Byte_HEX}
Byte_BIN = ${Zero ~ B ~ (Underline? ~ ASCII_BIN_DIGIT)+}
Byte_OCT = ${Zero ~ O ~ (Underline? ~ ASCII_OCT_DIGIT)+}
Byte_HEX = ${Zero ~ X ~ (Underline? ~ ASCII_HEX_DIGIT)+}
/*====================================================================================================================*/
//!#D19A66: Integer|Decimal|DecimalBad
Number     = ${Complex|Decimal|DecimalBad|Integer}
Decimal    = ${Integer ~Dot~ ASCII_DIGIT+}
DecimalBad = ${Integer~Dot | Dot~ASCII_DIGIT+}
Complex    = {(Decimal|Integer)~ SYMBOL}
Integer    = @{Zero|ASCII_DIGIT ~ (Underline? ~ ASCII_NONZERO_DIGIT)*}
/*====================================================================================================================*/
//!#3C963C: String
//!#98C379: StringText|StringLiteralText
String            = ${SYMBOL? ~ (StringNormal|StringLiteral|StringEmpty)}
StringLiteral     = {StringStart ~ StringLiteralText ~ StringEnd}
StringNormal      = {Quotation ~ StringText ~ Quotation}
StringEmpty       = {Quotation{2}|Apostrophe{2}}
StringLiteralText = {(!(Apostrophe ~ PEEK) ~ ANY)*}
StringText        = {(Solidus~(Solidus|Quotation)|!Quotation ~ ANY)*}
StringStart       = @{Apostrophe{1}~PUSH(Apostrophe*)}
StringEnd         = @{POP ~ Apostrophe{1}}
/*====================================================================================================================*/
// NEWLINE = @{"\r"~"\n"|"\r"|"\n"}
WHITESPACE = _{NEWLINE|SPACE_SEPARATOR|"\t"}
//!#7F848E: MultiLineComment
COMMENT = {MultiLineComment|LineCommentSimple|LineCommentTodo|LineCommentFixme|LineCommentWarning}
///Gray
LineCommentSimple = ${ "///" ~ (!NEWLINE ~ ANY)*}
///Green
LineCommentTodo = ${ "//?" ~ (!NEWLINE ~ ANY)*}
///Red
LineCommentFixme = ${ "//!" ~ (!NEWLINE ~ ANY)*}
///Yellow
LineCommentWarning = ${ "//*" ~ (!NEWLINE ~ ANY)*}
///Gray
MultiLineComment = ${ "%%%" ~ (MultiLineComment | !"%%%" ~ ANY)* ~ "%%%"}
/*====================================================================================================================*/
//!
Symbol = ${SYMBOL|namespace}
namespace = ${SYMBOL ~ (Proportion ~ SYMBOL)+}
SYMBOL = @{
    XID_START ~  XID_CONTINUE*
  | Underline ~ XID_CONTINUE+
}
/*====================================================================================================================*/
Zero = _{"0"}
X = _{"x"|"X"}
O = _{"o"|"O"}
B = _{"b"|"B"}
/*====================================================================================================================*/
//!#56B6C2: Prefix|Infix|Postfix
Prefix = @{
    Bang|Plus|Minus|Star
}
Postfix = @{
    Bang
  | DoubleBang
}
Infix = _{
    Plus|Minus
  | Multiply|CenterDot|Kronecker|TensorProduct|Divide|Quotient|Modulo
  | Power
  | Grater|GraterEqual|Equal
  | Dot
}

///#56B6C2
Set = @{"="}

Or = @{"|"}
LazyOr = @{"||"}


Star =@{"*"}
Slash =@{"/"}
Solidus = @{"\\"}

Proportion = @{"::"|"∷"}//U+2237
Comma =@{","|"，"} //U+FF0C
Dot = @{"."}
Separate = @{";;"}
Semicolon = @{";" | "；"} //U+FF1B
Colon = @{":"|"："} //U+FF1A
///#56B6C2
Question=@{"?"}
Underline = @{"_"}



Load =@{"<<<"|"⋘"} //U+22D8
Save =@{">>>"|"⋙"} //U+22D9
LeftShift =@{"<<"|"≪"} //U+226A
RightShift =@{">>"|"≫"} //U+226B
LessEqual =@{"<="}
GraterEqual =@{">="}
Less =@{"<"}
Grater =@{">"}



Equivalent =@{"==="}
NotEquivalent =@{"=!="}
Equal =@{"=="}
NotEqual =@{"!="|"≠"} //U+2260







Plus =@{"+"}
Minus =@{"-"}



Multiply =@{Star | "×"} //U+00D7
CenterDot = @{"⋅"} //U+22C5
Kronecker =@{"⊗"} //U+2297
TensorProduct=@{"⊙"} //U+2299
Divide = @{Slash | "÷"} //U+00F7
Quotient = @{"//"}
Modulo = @{"%"}
Remainder =@{"⁒"} //U+2052 //⸓


Power = @{"^"}
Surd = @{"√"} //U+221A


Increase =@{"++"}
Decrease =@{"--"}


To =@{"->"}


Elvis =@{":?"}
Map =@ {"/@"}


Quote =@{"`"}
Acute =@{"´"} // U+00B4
Apostrophe = @{"'"}
Quotation = @{"\""}


LogicOr =@{"||"|"∧"} //U+2227
LogicAnd =@{"&&"|"∨"} //U+2228
LogicNot =@{"¬"} //U+00AC

Ellipsis =@{"..."|"…"} // U+2026




LogicXor =@{"⊕"} //U+2295
MapAll =@{"//@"}

Output =@{"%%"}

Concat =@{"~~"}
Destruct =@{"~="}


DoubleBang =@{"!!"}
Bang =@{"!"}

Sharp =@{"#"}

Curry =@{"@@@"}
Apply =@{"@@"}
At    =@{"@"}